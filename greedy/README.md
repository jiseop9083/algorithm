# 그리디 알고리즘 (greedy algorithm)

## 그리디란?
- 이름처럼 greedy, 탐욕스러운 알고리즘이다.
- **각 단계마다 가장 좋은 방법을 선택**하여 최적해를 구하는 방법이다.
- 물론, 대부분의 문제에서 통하지 않는 방법이지만,
- 특정 경우(그리디를 쓸 수 있는 경우)에서는 다른 알고리즘보다 빠른 시간 내에 풀 수 있다.
- 다르게 말하면, **그리디로 풀 수 있는 문제는 DP로도 풀 수 있다!**
- 직관적으로 문제를 해결하는 간단한 방법이 있을 것같고 시간제한이 작다면 그리디를 의심해라!
- 직관이 필요한 알고리즘이므로 바로 문제를 보자.

---

## 백준 1931번 회의실배정
<br/><https://www.acmicpc.net/problem/1931>
- 회의실이 하나이고 회의의 최대 개수를 구하는 문제이다.
- 몇 가지 방법이 떠오를 것이다
- 가장 짧은 회의를 먼저한다. 가장 먼저 끝나는 회의를 선택한다. 가장 먼저 시작하는 회의를 선택한다 등등
- 탐욕적으로 해결할 수 있는 방법은 **가장 먼저 끝나는 회의를 선택**하는 것이다.


## 백준 14241번 슬라임 합치기
<br/><https://www.acmicpc.net/problem/14241>
 - 슬라임을 합쳤을 때 점수의 최솟값을 구하는 것이다.
 - x와 y를 합칠 때 xy가 추가되니 왠지 큰 슬라임부터 합치면 될 것 같다.
 - 직관적으로 맞다고 생각이 들면 바로 풀어도된다.
 - 하지만 왜 그런지 생각을 함 해보자
<br/>
 - 어떤 두 슬라임 x, y을 합칠 때, ```x + y >= 2sqrt(x*y)```을 만족한다. (x, y 둘다 양수) 
 - 이 때, ```2sqrt(x*y)```는 증가하므로 ```x + y - 2sqrt(x*y) = (x - Y)^2```값이 커질수록 ```x + y```와 ```x*y``` 차이는 커진다.
 - 즉, x와 y의 차가 커지는 경우를 선택해야한다.
 - n개의 슬라임 중 가장 작은 슬라임과 나머지 슬라임 덩어리를 합칠때 최적해를 도출할 수 있다.
 - 나머지 슬라임 덩어리를 만드는데 점수도 같은 과정으로 도출할 수 있다.
 - 이 과정을 역으로 생각하면, 슬라임 중 가장 큰 2개를 골라 합치는 과정을 반복해야한다는 결론이 도출된다.
 - 핵심코드는 다음과 같다.
 
 ```
 	//우선순위큐를 사용해 계산을 빠르게
 	//큐 안에 1개의 값이 남을 때까지 반복
	while (pq.size() >= 2) {
  	//가장 큰 값 2개 빼내기
		int first = pq.top();
		pq.pop();
		int second = pq.top();
		pq.pop();
    	//답추가
		an += first * second;
		pq.push(first + second);
	}
```

끝
 

