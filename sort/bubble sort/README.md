# 거품정렬(bubble sort)
 - 인접한 원소를 검사하여 정렬하는 알고리즘이다
 - 마치 정렬하는 과정이 거품이 올라오는 것 같다.
 - 인접한 두 수를 비교하여 큰 수를 뒤로 보내자
 
 
 ## procedure(의사 코드) buble sort
  - (a[1], a[2],....,a[n] : real number, n >= 2)
  ```
  for i= 1 to n- 1
      for j:= i to n- i
          if a[j] > a[j + 1] then interchange aj and aj+i
  return max {a[1], ...., a[n] is in increasing order}
   ```

 ## 예시
  - 예를 들어, 다섯 개의 숫자가 주어졌다고 하자.
  ---
  > **6, 2, 4, 3 ,7**
  1. 6과 2를 비교했을때 6이 더 큰 수이므로, 두 수의 자리를 바꾼다.

  > **2, 6**, 4, 3, 7

  2. 4과 6을 비교했을때 6이 더 크므로, 두 수의 자리를 바꾼다.

  > 2, **4, 6**, 3, 7

  3. 6과 3를 비교했을때, 6이 더 크므로, 두 수의 자리를 바꾼다.

  > 2, 4, **3, 6**, 7

  4. 6과 7을 비교했을때, 7이 더 크므로, 두 수의 자리를 바꾸지 않는다.

  > 2, 4, 3, **6, 7**

  5. 1부터 4까지의 과정을 한번의 순회라고 한다.
  한 번의 순회를 끝내면 가장 큰 원소가 맨뒤로 오게 된다. 

  6. 고로, 1부터 4까지의 과정을 원소의 개수(5번)만큼 반복하면 된다.
  
  - 다른 정렬 알고리즘에 비해 작성이 간단하지만, 시간복잡도(n^2)가 크다는 단점이 있다.
  
 ## 코드
  ```
  //arr: 정렬할 배열, len: 배열의 길이
  void bubble_sort(int* arr, int len){
    for(int i = 0; i < len - 1; i++){
      for(int j = 0; j <len - i - 1; j++) {
        //바꾸어야하는 경우
        if (arr[j] > arr[j + 1]) {
          int swap = arr[j];
          arr[j] = arr[j + 1];
          arr[j + 1] = swap;
        }
      }
    }
  }
  ```
